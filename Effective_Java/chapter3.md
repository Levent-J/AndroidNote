1.不覆盖equals的情况：
	类的每个实例本质上都是唯一的
	不关心类是否提供了逻辑相等的测试功能
	超类已经覆盖了equals且子类继承过来的行为也是合适的
	类是私有的或包级私有的，即equals方法永远不会被调用
2.覆盖equals的理由：类具有自己的“逻辑相等”概念，且超类没有覆盖equals以实现期望的行为
3.覆盖equals要遵循的约定：自反性、对称性、传递性、一致性、非空性
4.无法做到在扩展可实例化的类的同时，既增加新的值组件，又保留equals约定——复合优先于继承
5.是实现高质量equals的诀窍：
	使用==操作符检查引用是否相同
	使用instanceof判断参数类型是否相符
	把参数转为正确的类型
	对每个关键域都检查是否匹配相等
6.覆盖equals要注意：
	覆盖equals时总要覆盖hashCode
	不要将方法中的Object转变为其他类型
7.在每个覆盖了equals的方法中，同样要覆盖hashCode方法
8.对同一个对象调用多次hashCode，返回的结果必须不能变
9.不要试图从散列码计算中排除掉一个对象的关键部分来提高性能
10.始终要覆盖toString
11.Cloneable决定了Object中受保护的clone方法实现的行为：如果一个类实现了Cloneable，clone方法就应该返回该对象的逐域拷贝
12.如果覆盖了非final类的clone方法，应该返回一个通过调用super.clone而得到的对象
13.clone方法就是另一个构造器，必须确保他不能伤害到原始的对象
14.如果线程安全的类实现了Cloneable接口，必须让clone方法得到同步
15.实现Comparable接口要注意：自反性、传递性
16.无法在用新的值组件扩展可实例化的类的同时保持compareTo约定
17.如果一个域没有实现Comparable借口，可以用一个显式的Comparator代替
