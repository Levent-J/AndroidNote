# 第四章 类和接口
1.隐藏本身不会带来更好的性能，但可以有效的调节性能  
2.经可能的使每个类或者成员不被外界访问  
3.如果一个包级私有的顶层类或者接口只在某一个类的内部用到，应该考虑让他成为那个类的私有嵌套类  
4.可访问性总结：  
  - private(私有的)：只有在声明该成员的顶层类中可以使用  
  - package-navie(包级私有)：声明该成员的包内部的任何类都可以访问，是默认的的访问级别  
  - protected(受保护的)：声明该成员的类的子类和该类的包内其他类都可以访问
  - public(公有的)：任何类都可以访问  

5.只有当同一个包内的另一个类真正需要访问一个成员时，才应该删除他的private修饰符  
6.私有成员和包级私有成员都是一个类的实现中的一种，不会影响他的导出API  
7.如果方法覆盖了超类中的一个方法，那他的访问级别不能低于超类  
8.对于可变的类来说，应该用包级私有域和公有设置方法  
9.如果类可以在他所在的包外部进行访问，就提供访问方法  
10.使类变得不可变要遵循的规则：
 - 不要提供任何会修改的方法
 - 使所有的域都是final的
 - 保证类不会被扩展
 - 使所有的域都成为私有的
 - 确保对于任何可变组件的互斥访问  


 11.不可变对象可以只有一种状态，即被创建时的状态  
 12.不可变对象本质上是线程安全的，不要求同步  
 13.不可变类的唯一缺点是，对每个不同的值都需要一个单独的对象  
 14.不要总是为每一个get方法写相应的set方法  
 15.尽量让每个域都是final的  
 16.不要在构造器或静态工厂方法之外再提供公有的初始化方法  
 17.子类必须跟着其超类的更新而演变  
 18.导致子类脆弱的一个原因是超类在后续的开发中可能还会添加新的方法  
 19.包装类不适合用在回调框架中  
 20.只有当子类真正时超类的一个子类型时才适合使用继承  
 21.继承会让超类中的缺陷也传播到子类中  
 22.类必须用文档说明哪些方法是可以覆盖的，哪些不可以  
 23.对于为了继承而设计的类，唯一的测试方法就是编写他的子类  
 24.构造器绝不可调用可被覆盖的方法，无论是直接还是间接调用  
 25.超类的构造器永远会在子类的构造器前执行  
 26.clone和readObject斗不可调用可被覆盖的方法  
 27.抽象类可以包含部分实现，接口不允许  
 28.接口一旦被公开发行，且被实现，就不应该再改这个接口  
 29.类层次可以用来反映类型之间的层次上的关系  
 30.通过定义一种对象，他的方法执行其他对象上的操作，这样来实现函数指针/lambda表达式
