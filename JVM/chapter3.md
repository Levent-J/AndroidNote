# 第三章 垃圾收集器与内存分配策略
## 对象已死吗？
### 1.引用计数法
1.主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是他很难解决对象之间互相引用的问题。  
### 2.可达性分析算法  
1.主流的商用程序语言的主流实现中都是用可达性分析来判断对象是否存活的  
2.从一个起始对象GC Roots开始向下搜索，搜索所走过的路径称为引用链，档一个对象到GC Roots没有任何引用链时，即从GC Roots到这个对象不可达，则证明此对象是不可用的  
3.在Java语言中，可作为GC Roots的对象包括一下四种：
 - 虚拟机栈（栈帧中的本地变量表）中引用的对象  
 - 方法区中类静态属性引用的对象  
 - 方法区中常亮引用的对象  
 - 本地方法栈中JNI引用的对象  

### 3.再谈引用  
1.Java的引用可以分为强引用、软引用、弱引用、虚引用：  
 - 强引用：是指在程序代码中直接存在的引用，譬如引用new操作符创建的对象。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象  
 - 软引用：还有用但是并非必需的引用，早系统将要发生内存溢出异常之前会把这些对象列进回收范围中进行二次回收，若还是没有足够的内存，才会抛出内存溢出异常  
 - 弱引用：非必需的对象，只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论内存是否够用都将回收这些对象  
 - 虚引用：一个对象是否有虚引用的存在完全不会对他的生存时间构成影响，也无法通过虚引用来取得一个对象实例  

### 4.生存还是死亡  
1.要真正宣告一个对象死亡，需要两个标记过程：
  -   若对象在进行可达性分析后发现没有与GC Roots相连接的引用链，会被第一次标记并筛选。筛选的条件是此对象是否有必要执行finalize()方法  
  - finalize()方法是对象逃脱死亡的最后一次机会，稍后GC会对对象进行第二次标记  

2.当对象没有覆盖finalize()方法或者finalize()方法已经由虚拟机调用过，都视为finalize()没有必要执行  
### 5.回收方法区
1.永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类  
2.类需要同时满足一下三个条件才能算是“无用的类”：
 - 该类所有的实例都已经被回收，即Java堆中不再有该类的实例  
 - 加载该类的ClassLoader已经被回收  
 - 该类对应的java.lang.Class对象没有在任何地方被调用，无法在任何地方通过反射访问该类的方法  
 
