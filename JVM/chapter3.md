# 第三章 垃圾收集器与内存分配策略
## 对象已死吗？
### 1.引用计数法
1.主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是他很难解决对象之间互相引用的问题。  
### 2.可达性分析算法  
1.主流的商用程序语言的主流实现中都是用可达性分析来判断对象是否存活的  
2.从一个起始对象GC Roots开始向下搜索，搜索所走过的路径称为引用链，档一个对象到GC Roots没有任何引用链时，即从GC Roots到这个对象不可达，则证明此对象是不可用的  
3.在Java语言中，可作为GC Roots的对象包括一下四种：
 - 虚拟机栈（栈帧中的本地变量表）中引用的对象  
 - 方法区中类静态属性引用的对象  
 - 方法区中常亮引用的对象  
 - 本地方法栈中JNI引用的对象  

### 3.再谈引用  
1.Java的引用可以分为强引用、软引用、弱引用、虚引用：  
 - 强引用：是指在程序代码中直接存在的引用，譬如引用new操作符创建的对象。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象  
 - 软引用：还有用但是并非必需的引用，早系统将要发生内存溢出异常之前会把这些对象列进回收范围中进行二次回收，若还是没有足够的内存，才会抛出内存溢出异常  
 - 弱引用：非必需的对象，只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论内存是否够用都将回收这些对象  
 - 虚引用：一个对象是否有虚引用的存在完全不会对他的生存时间构成影响，也无法通过虚引用来取得一个对象实例  

### 4.生存还是死亡  
1.要真正宣告一个对象死亡，需要两个标记过程：
  -   若对象在进行可达性分析后发现没有与GC Roots相连接的引用链，会被第一次标记并筛选。筛选的条件是此对象是否有必要执行finalize()方法  
  - finalize()方法是对象逃脱死亡的最后一次机会，稍后GC会对对象进行第二次标记  

2.当对象没有覆盖finalize()方法或者finalize()方法已经由虚拟机调用过，都视为finalize()没有必要执行  
### 5.回收方法区
1.永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类  
2.类需要同时满足一下三个条件才能算是“无用的类”：
 - 该类所有的实例都已经被回收，即Java堆中不再有该类的实例  
 - 加载该类的ClassLoader已经被回收  
 - 该类对应的java.lang.Class对象没有在任何地方被调用，无法在任何地方通过反射访问该类的方法  
## 垃圾收集算法
### 1.标记-清楚算法

1.算法分为两个阶段：标记和清除  
 - 标记：标记所有需要回收的对象  
 - 清除：统一回收所有被标记的对象  

2.优点:简单，是后面其他算法的基础  
3.缺点：标记和清除的效率很低；标记清除之后会产生大量不连续的内存碎片，空间碎片太多会导致以后遇到大对象的时候无法找到足够的内存  

### 2.复制算法

1.思路：将可用内存按容量分为两个块，每次只用其中之一。当这一块内存用完之后，将还存活的对象复制到另一边去，然后清除所有已经使用过的部分  
2.优点：实现简单，运行高效  
3.缺点：代价是将内存缩小了一部分，而且可能会需要额外的担保空间  

### 3.标记-整理算法  

1.思路：标记过程和标记-清除一样，但是后续步骤不是直接对可回收对象进行清理，而是将所有活着的对象向一端移动，然后直接清理掉端边界以外的内存  

### 4.分代收集算法

1.当前商用虚拟机都采用了这种算法，根据对象的存活周期将内存划分为几块，一般是把Java堆分为新生代和老生代，根据各个年代采用适当的收集算法  
2.新生代一般采用复制算法，老生代一搬采用 标记-清理 或者标记-整理 进行回收  
