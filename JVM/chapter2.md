# 第二章 Java内存区域与内存溢出异常

## 运行时数据区域

Java虚拟机会把他所管理的内存划分为若干个不同的数据区域：

| 由线程共享  | 线程隔离区域  |
| :------------- | :------------- |
| 方法区       | 虚拟机栈       |  
| 堆       | 本地方法栈       |  
| Item One       | 程序计数器       |  

### 1.程序计数器
1.程序计数器是当前线程所执行的字节码的行号指示器  
2.在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令  
3.如果正在执行一个Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；如果是native方法，则计数器值为空  
### 2.Java虚拟机栈
1.虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧，用于存储局部变量、操作数栈、动态链接、方法出口等信息  
2.通常所说的“Java内存分为堆内存和栈内存”是过于粗糙的，其中的栈所指的实际上是虚拟机栈，确切的说是虚拟机栈中的局部变量表  
3.long 和 double型的数据会占用2个局部变量空间，其余的数据类型只占用1个  
4.局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法在帧中要分配多大的局部变量空间是完全确定的  
### 3.本地方法栈
1.本地方法栈和虚拟机栈的区别在于，虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为Native放法服务  
2.有的虚拟机，如HotSpot，直接把本地方法栈和虚拟机栈合二为一  
### 4.Java堆
1.Java堆是Java虚拟机所管理的内存中最大的一块  
2.Java堆在虚拟机启动时创建，被所有线程共享  
3.Java堆唯一的目的是存放对象实例，几乎所有的对象实例和数组都在这里  
4.Java堆为了便于更好的回收和分配内存，可以细分为：“新生代和老生代”，或者“Eden\ From Survivor\ To Survivor等”  
5.Java堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的即可  
### 5.方法区
1.方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据  
2.如何实现方法区属于虚拟机的实现细节，不受虚拟机规范约束  
3.方法区可以选择不实现垃圾回收  
4.方法区的内存回收目标主要针对常量池的回收和对类型的卸载  
### 6.其他
1.运行时常量池用于存放编译器生成的各种字面量和符号引用  
2.直接内存不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域
